#ventas/models/venta
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from datetime import date
from odoo import SUPERUSER_ID

class venta(models.Model):
    _name = 'ventas.venta'
    _description = 'Venta de artículos'
    
    cliente = fields.Many2one('clientes.cliente', string="Cliente", required=True)
    contrato = fields.Many2one('creditos.credito', string="Contrato",
                               domain="[('cliente', '=', cliente), ('contratoactivo','=',True), ('vencimiento', '>', context_today())]" if cliente else "[('id', '=', 0)]")

    # Calcula siempre la fecha actual sin depender de otros campos
    hoy = fields.Date(compute='_compute_hoy')
    @api.depends()
    def _compute_hoy(self):
        for record in self:
            record.hoy = date.today()

    def action_noop(self):
        """Usado por los tiles de cabecera: no hace nada."""
        return False


    observaciones = fields.Char(string="Observaciones", size=48)
    fecha = fields.Date(string="Fecha", readonly=True, copy=False, index=True)
    importe = fields.Float(string="Importe", readonly=True, store=True, compute='_add_detalles')
    iva = fields.Float(string="iva", readonly=True, store=True, compute='_add_detalles')
    ieps = fields.Float(string="ieps", readonly=True, store=True, compute='_add_detalles')
    total = fields.Float(string="Total", readonly=True, store=True, compute='_add_detalles')
    activa = fields.Boolean(string="Activa", default=True)

    detalle = fields.One2many('transacciones.transaccion', 'venta_id', string="Venta")

    # Empresa con default por ID
    empresa_id = fields.Many2one(
        'empresas.empresa', string='Empresa', required=True,
        default=lambda self: self.env.user.empresa_actual_id.id,
    )

    # Sucursal con default por ID
    sucursal_id = fields.Many2one(
        'sucursales.sucursal', string='Sucursal', required=True,
        default=lambda self: self.env.user.sucursal_actual_id.id,
    )

    @api.onchange('empresa_id')
    def _onchange_empresa_id(self):
        # Si la sucursal elegida no pertenece a la empresa, límpiala
        if self.sucursal_id and self.sucursal_id.empresa != self.empresa_id:
            self.sucursal_id = False
        # No devuelvas dominios aquí (en v14+ está deprecado). :contentReference[oaicite:1]{index=1}

    @api.onchange('sucursal_id')
    def _onchange_sucursal(self):
        if self.sucursal_id:
            self.empresa_id = self.sucursal_id.empresa

    @api.constrains('sucursal_id', 'empresa_id')
    def _check_sucursal_empresa(self):
        for r in self:
            if r.sucursal_id and r.sucursal_id.empresa != r.empresa_id:
                raise ValidationError(_("La sucursal no pertenece a la empresa seleccionada."))

    # Folio
    codigo = fields.Char(string="Folio", readonly=True, copy=False, index=True)

    state = fields.Selection(
        [('draft', 'Borrador'), ('confirmed', 'Confirmada'), ('cancelled', 'Cancelada'), ('invoiced', 'Facturada')],
        string="Estado", default='draft', required=True, index=True
    )

    is_editing = fields.Boolean(default=False, store=True)

    # NEW: para no aplicar/revertir stock dos veces
    stock_aplicado = fields.Boolean(default=False, copy=False)

    _sql_constraints = [
        ('venta_codigo_uniq', 'unique(codigo)', 'El código de la venta debe ser único.'),
    ]

    @api.onchange('cliente')
    def _onchange_cliente(self):
        self.contrato = False
        # (dejas tu filtrado por dominio server-side si luego lo reactivas)

    # Método de pago
    metododepago = fields.Selection(
        selection=[("PPD", "Crédíto"), ("PUE", "Contado")],
        string="Método de Pago", required=True, default="PPD", store=True
    )

    # Forma de pago SAT
    formadepago = fields.Selection(
        selection=[
            ("01", "Efectivo"), ("02", "Cheque Nominativo"), ("03", "Transferencia"),
            ("04", "Tarjeta de Crédito"), ("15", "Condonación"), ("17", "Compensación"),
            ("28", "Tarjeta de Débito"), ("30", "Aplicación de Anticipos"), ("99", "Por Definir")
        ],
        string="Forma de Pago", default="01"
    )

    @api.onchange('metododepago')
    def _chgmpago(self):
        for record in self:
            if record.metododepago == 'PPD':
                record.formadepago = '99'
        self._apply_prices_by_method()

    def _apply_prices_by_method(self):
        """Forzar precio de líneas según PUE/PPD (mantengo tu lógica)."""
        for v in self:
            metodo = v.metododepago or 'PPD'
            for line in v.detalle:
                if line.producto_id:
                    line.precio = line.producto_id.contado if metodo == 'PUE' else line.producto_id.credito

    @api.depends('detalle.subtotal', 'detalle.iva_amount', 'detalle.ieps_amount', 'detalle.importe')
    def _add_detalles(self):
        for rec in self:
            rec.importe = sum(l.subtotal for l in rec.detalle)
            rec.iva     = sum(l.iva_amount for l in rec.detalle)
            rec.ieps    = sum(l.ieps_amount for l in rec.detalle)
            rec.total   = sum(l.importe for l in rec.detalle)

    @api.constrains('detalle')
    def _check_detalle_venta(self):
        for record in self:
            if not record.detalle:
                raise ValidationError(_('No se puede guardar una venta sin al menos un producto.'))
            for linea in record.detalle:
                if linea.cantidad <= 0 or linea.precio <= 0:
                    raise ValidationError(_('La Cantidad/Precio no pueden ser 0'))
                if not linea.producto_id:
                    raise ValidationError(_('Debe seleccionar un producto'))

    def action_open_edit(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': 'Editar Venta',
            'res_model': 'ventas.venta',
            'view_mode': 'form',
            'view_id': self.env.ref('ventas.view_venta_form').id,
            'res_id': self.id,
            'target': 'current',
            'context': {'form_view_initial_mode': 'edit'},
        }

    # =========================
    # Lógica de inventario
    # =========================

    def _get_stock_moves(self):
        """
        Agrupa las SALIDAS por producto para esta venta.
        Considera solo líneas con cantidad > 0 y tipo 'Salida'.
        Usamos preferentemente line.stock == '2' (si tu compute existe);
        si no existe, caemos a tipo == '1' (Venta).
        """
        self.ensure_one()
        moves = {}
        for line in self.detalle:
            es_salida = False
            # preferente: campo 'stock' (2 = Salida)
            if hasattr(line, 'stock') and line.stock == '2':
                es_salida = True
            # fallback: campo 'tipo' (1 = Venta)
            elif hasattr(line, 'tipo') and line.tipo == '1':
                es_salida = True

            if es_salida and line.cantidad > 0 and line.producto_id:
                pid = line.producto_id.id
                moves[pid] = moves.get(pid, 0.0) + line.cantidad
        return moves

    def _check_stock_before_confirm(self):
        Stock = self.env['stock.sucursal.producto']
        for sale in self:
            if not sale.sucursal_id:
                raise ValidationError(_("Debe seleccionar la sucursal de la venta."))
            moves = sale._get_stock_moves()
            for pid, qty in moves.items():
                prod = self.env['productos.producto'].browse(pid)
                disponible = Stock.get_available(sale.sucursal_id, prod)
                if disponible < qty:
                    raise ValidationError(_(
                        "Stock insuficiente para confirmar.\nProducto: %(prod)s\nSucursal: %(suc)s\nDisponible: %(disp).4f\nRequerido: %(req).4f"
                    ) % {
                        "prod": prod.display_name,
                        "suc": sale.sucursal_id.display_name,
                        "disp": disponible,
                        "req": qty,
                    })
            # Validación suave: las líneas deben coincidir en sucursal (si traen ese campo)
            for line in sale.detalle:
                if hasattr(line, 'sucursal_id') and line.sucursal_id and line.sucursal_id != sale.sucursal_id:
                    raise ValidationError(_("La sucursal de cada línea debe coincidir con la sucursal de la venta."))

    def _apply_stock_on_confirm(self):
        Stock = self.env['stock.sucursal.producto']
        for sale in self:
            moves = sale._get_stock_moves()
            for pid, qty in moves.items():
                prod = self.env['productos.producto'].browse(pid)
                Stock.remove_stock(sale.sucursal_id, prod, qty)
            sale.stock_aplicado = True

    def _revert_stock_on_cancel(self):
        Stock = self.env['stock.sucursal.producto']
        for sale in self:
            if not sale.stock_aplicado:
                continue
            moves = sale._get_stock_moves()
            for pid, qty in moves.items():
                prod = self.env['productos.producto'].browse(pid)
                Stock.add_stock(sale.sucursal_id, prod, qty)
            sale.stock_aplicado = False

    # Acciones de workflow
    def action_confirm(self):
        for sale in self:
            if sale.state != 'draft':
                raise ValidationError(_("Solo se puede confirmar desde Borrador."))
        self._check_stock_before_confirm()
        self._apply_stock_on_confirm()

        today = fields.Date.context_today(self)
        for sale in self:
            vals = {'state': 'confirmed'}
            if not sale.fecha:
                vals['fecha'] = today
            if not sale.codigo:
                vals['codigo'] = sale._next_folio()
            sale.sudo().write(vals)
            #sale.write(vals)  # escribe con el usuario real

        return True

    def action_cancel(self):
        for sale in self:
            if sale.state not in ('confirmed', 'invoiced'):
                raise ValidationError(_("Solo se puede cancelar una venta Confirmada o Facturada."))
        self._revert_stock_on_cancel()
        self.write({'state': 'cancelled'})
        return True

    def write(self, vals):
        for rec in self:
            if rec.state == 'cancelled':
                raise ValidationError(_("Venta cancelada: no se permite editar."))

            # ✅ Solo valida permisos si se intenta cambiar empresa/sucursal
            if 'empresa_id' in vals or 'sucursal_id' in vals:
                rec._check_user_company_branch(vals=vals)

        return super().write(vals)

    
    def _check_user_company_branch(self, vals=None):
        user = self.env.user
        for rec in (self if self else self.browse()):
            empresa_id = (vals or {}).get('empresa_id', rec.empresa_id.id)
            sucursal_id = (vals or {}).get('sucursal_id', rec.sucursal_id.id)

            if empresa_id and empresa_id not in user.empresas_ids.ids:
                raise ValidationError(_("No tienes permiso para usar la empresa seleccionada."))

            if sucursal_id and sucursal_id not in user.sucursales_ids.ids:
                raise ValidationError(_("No tienes permiso para usar la sucursal seleccionada."))

            if empresa_id and sucursal_id:
                suc = self.env['sucursales.sucursal'].browse(sucursal_id)
                if suc.empresa.id != empresa_id:
                    raise ValidationError(_("La sucursal '%s' no pertenece a la empresa seleccionada.") % (suc.display_name,))

    @api.model
    def create(self, vals):
        vals.setdefault('empresa_id', self.env.user.empresa_actual_id.id)
        vals.setdefault('sucursal_id', self.env.user.sucursal_actual_id.id)
        self._check_user_company_branch(vals=vals)
        return super().create(vals)


    def _next_folio(self):
        """Intenta usar una secuencia; ajusta el código si la tuya se llama distinto."""
        # Cambia 'ventas.venta.folio' por el código real de tu secuencia si ya existe
        seq_code_candidates = ['ventas.venta.folio', 'ventas.venta', 'seq.ventas.venta']
        IrSeq = self.env['ir.sequence']
        for code in seq_code_candidates:
            nxt = IrSeq.next_by_code(code)
            if nxt:
                return nxt
        # Si no hay secuencia configurada, arma un folio simple y único como fallback
        return self.env['ir.sequence'].next_by_code('base.sequence_mixin') or self._generate_default_folio()

    def _generate_default_folio(self):
        # Fallback ultra simple (no depende de data extra)
        return f"V-{fields.Datetime.now().strftime('%Y%m%d%H%M%S')}"

    def _check_user_company_branch(self, vals=None):
        # No validar para superusuario
        if self.env.uid == SUPERUSER_ID:
            return

        user = self.env.user
        for r in (self if self else self.browse()):
            empresa_id  = (vals or {}).get('empresa_id',  r.empresa_id.id)
            sucursal_id = (vals or {}).get('sucursal_id', r.sucursal_id.id)

            if empresa_id and empresa_id not in user.empresas_ids.ids:
                raise ValidationError(_("No tienes permiso para usar la empresa seleccionada."))
            if sucursal_id and sucursal_id not in user.sucursales_ids.ids:
                raise ValidationError(_("No tienes permiso para usar la sucursal seleccionada."))

            # Consistencia empresa–sucursal
            if empresa_id and sucursal_id:
                suc = self.env['sucursales.sucursal'].browse(sucursal_id)
                if suc.empresa.id != empresa_id:
                    raise ValidationError(_("La sucursal '%s' no pertenece a la empresa seleccionada.") % (suc.display_name,))

    # Estado/folio CFDI
    cfdi_state = fields.Selection([
        ('none', 'Sin CFDI'),
        ('to_stamp', 'Por timbrar'),
        ('stamped', 'Timbrado'),
        ('to_cancel', 'Por cancelar'),
        ('canceled', 'Cancelado'),
    ], default='none', string="Estado CFDI", copy=False)

    cfdi_uuid = fields.Char(string="UUID", copy=False, readonly=True)
    cfdi_tipo = fields.Selection([('I','Ingreso'),('E','Egreso'),('P','Pago')], string="Tipo CFDI", copy=False)
    cfdi_relacion_tipo = fields.Selection([
        ('01','Nota de crédito de los documentos relacionados'),
        ('02','Nota de débito de los documentos relacionados'),
        ('03','Devolución de mercancía sobre facturas o traslados previos'),
        ('04','Sustitución de los CFDI previos'),
        ('05','Traslados de mercancias facturados previamente'),
        ('06','Factura generada por los traslados previos'),
        ('07','CFDI por aplicación de anticipo'),
    ], string="Tipo de relación", copy=False)
    cfdi_relacion_ventas_ids = fields.Many2many('ventas.venta', 'venta_cfdi_rel_m2m', 'venta_id', 'rel_id',
                                                string="CFDIs relacionados", copy=False)

    def action_open_cfdi_wizard(self):
        """Abre el wizard para capturar Uso CFDI / Método / Relación, etc."""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Generar CFDI'),
            'res_model': 'ventas.cfdi.wizard',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_sale_id': self.id,
                'default_metodo_pago': self.metododepago or 'PPD',
                'default_forma_pago': self.formadepago or False,
            },
        }
    
    def _to_cfdi_conceptos(self):
     """Convierte líneas de venta a conceptos CFDI (placeholder simple)."""
     conceptos = []
     for l in self.detalle:
        if not l.producto_id:
            continue
        clave_prod_serv = getattr(l.producto_id, 'sat_clave_prod_serv', None) or '01010101'
        clave_unidad = getattr(l.producto_id, 'sat_clave_unidad', None) or 'H87'
        no_ident = getattr(l.producto_id, 'default_code', None) or str(l.producto_id.id)
        descripcion = getattr(l.producto_id, 'name', 'Producto')
        cantidad = l.cantidad or 1.0
        precio = l.precio or 0.0
        subtotal = getattr(l, 'subtotal', cantidad * precio)
        iva_amt = getattr(l, 'iva_amount', 0.0)
        ieps_amt = getattr(l, 'ieps_amount', 0.0)
        impuestos = {'traslados': []}
        if iva_amt:
            impuestos['traslados'].append({
                'impuesto': '002',      # IVA
                'tipo_factor': 'Tasa',
                'tasa_cuota': 0.16,     # ajusta según tu línea
                'base': subtotal,
                'importe': iva_amt,
            })
        if ieps_amt:
            impuestos['traslados'].append({
                'impuesto': '003',      # IEPS
                'tipo_factor': 'Tasa',
                'tasa_cuota': 0.08,     # ejemplo
                'base': subtotal,
                'importe': ieps_amt,
            })

        conceptos.append({
            'clave_sat': clave_prod_serv,
            'clave_unidad': clave_unidad,
            'no_identificacion': no_ident,
            'descripcion': descripcion,
            'cantidad': cantidad,
            'valor_unitario': precio,
            'importe': subtotal + iva_amt + ieps_amt,
            'objeto_imp': '02',  # gravado
            'impuestos': impuestos,
        })
     return conceptos

     # Contador de adjuntos (smart button)
    attachment_count = fields.Integer(compute='_compute_attachment_count')

    def _compute_attachment_count(self):
        Att = self.env['ir.attachment']
        for r in self:
            r.attachment_count = Att.search_count([('res_model', '=', r._name), ('res_id', '=', r.id)])

    def action_open_attachments(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Adjuntos'),
            'res_model': 'ir.attachment',
            'view_mode': 'list,form',  # <- IMPORTANTE
            'domain': [('res_model', '=', self._name), ('res_id', 'in', self.ids)],
            'context': {
                'default_res_model': self._name,
                'default_res_id': self.id,
            },
            'target': 'current',
        }

    def action_download_cfdi(self):
        self.ensure_one()
        att = self.env['ir.attachment'].search([
            ('res_model', '=', 'ventas.venta'),
            ('res_id', '=', self.id),
            ('mimetype', '=', 'application/xml'),
        ], limit=1, order='id desc')
        if not att:
            # Busca por doc de tu engine como fallback
            att = self.env['ir.attachment'].search([
                ('res_model', '=', 'mx.cfdi.document'),
                ('res_id', 'in', self.env['mx.cfdi.document'].search([
                    ('origin_model', '=', 'ventas.venta'),
                    ('origin_id', '=', self.id),
                    ('uuid', '=', self.cfdi_uuid),
                ]).ids),
                ('mimetype', '=', 'application/xml'),
            ], limit=1, order='id desc')
        if not att:
            raise ValidationError(_("No hay XML adjunto para esta venta."))

        return {
            'type': 'ir.actions.act_url',
            'url': f'/web/content/{att.id}?download=true',
            'target': 'self',
        }


